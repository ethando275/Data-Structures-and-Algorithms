

netid => ed8205
assignment => Autocomplete
file01 => @/n/fs/tigerfile/Files/COS226_S2023/Autocomplete/submissions/83b1c8d256f9a14c335f095b396df068/Term.java;filename=20230227152235/Term.java
file02 => @/n/fs/tigerfile/Files/COS226_S2023/Autocomplete/submissions/83b1c8d256f9a14c335f095b396df068/Autocomplete.java;filename=20230227152240/Autocomplete.java
file03 => @/n/fs/tigerfile/Files/COS226_S2023/Autocomplete/submissions/83b1c8d256f9a14c335f095b396df068/BinarySearchDeluxe.java;filename=20230227152244/BinarySearchDeluxe.java
The following files were submitted:
----------------------------------
 3.5K Feb 27 15:22 Autocomplete.java
 2.6K Feb 27 15:22 BinarySearchDeluxe.java
 3.5K Feb 27 15:22 Term.java
*** MISSING readme.txt ***


*** The acknowledgments.txt file has NOT been submitted.***
*** This assessment will NOT be graded until the acknowledgments.txt file is submitted.***


********************************************************************************
*  COMPILING                                                                    
********************************************************************************


% javac Term.java
*-----------------------------------------------------------

% javac BinarySearchDeluxe.java
*-----------------------------------------------------------

% javac Autocomplete.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Term:
The following nested classes must either be removed or made private:
  * PrefixOrder
  * ReverseWeightOrder


BinarySearchDeluxe:

Autocomplete:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS                                       
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D IM_AVERAGE_COMPUTATION_COULD_OVERFLOW IM: Computes the average of two integers using code like '(lo + hi) / 2' or '(lo + hi) >> 1', which is susceptible to overflow. Assuming the result is non-negative, use code like 'lo + (hi - lo) / 2' or '(lo + hi) >>> 1'.  At BinarySearchDeluxe.java:[line 18]
M D IM_AVERAGE_COMPUTATION_COULD_OVERFLOW IM: Computes the average of two integers using code like '(lo + hi) / 2' or '(lo + hi) >> 1', which is susceptible to overflow. Assuming the result is non-negative, use code like 'lo + (hi - lo) / 2' or '(lo + hi) >>> 1'.  At BinarySearchDeluxe.java:[line 44]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'termList', exposing the internal representation of the class 'Autocomplete'. Instead, create a defensive copy of the object referenced by the parameter variable 'terms' and store that copy in the instance variable 'termList'.  At Autocomplete.java:[line 25]
SpotBugs ends with 3 warnings.


================================================================


% pmd .
*-----------------------------------------------------------


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Term.java
*-----------------------------------------------------------
Checkstyle ends with 2 errors.
[ERROR] Term.java:71:30: Creating a substring of length r takes time proportional to r. The string comparison functions should take time proportional to the number of characters needed to resolve the comparison, which might be much less than r. [Performance]
[ERROR] Term.java:72:30: Creating a substring of length r takes time proportional to r. The string comparison functions should take time proportional to the number of characters needed to resolve the comparison, which might be much less than r. [Performance]
Checkstyle ends with 2 errors and 0 warnings.

% custom checkstyle checks for BinarySearchDeluxe.java
*-----------------------------------------------------------

% custom checkstyle checks for Autocomplete.java
*-----------------------------------------------------------
[INFO] Autocomplete.java:24:16: This program calls 'Arrays.sort()' from 'Autocomplete()'. This message is intended to assist the grader and does not necessarily indicate an error. [GraderInfo]
[INFO] Autocomplete.java:55:16: This program calls 'Arrays.sort()' from 'allMatches()'. This message is intended to assist the grader and does not necessarily indicate an error. [GraderInfo]


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Term
*-----------------------------------------------------------
Running 17 total tests.

The tests use the following notation:
  - m     = expected length of random string 1
  - n     = expected length of random string 2
  - ALPHA = alphabet
  - w     = weights are between 0 and w-1
  - r     = argument to byPrefixOrder()

Test 1a: check that compareTo() satisfies Comparable contract
  * reflexive:     m = 20, w = 1000000
  * reflexive:     m =  4, w = 10
  * antisymmetric: m = 20, w = 1000000
  * antisymmetric: m =  4, w = 10
  * transitive:    m = 20, w = 1000000
  * transitive:    m =  4, w = 10
  * consistent:    m =  4, w = 1000000
  * argument is null
==> passed

Test 1b: check correctness of compareTo() with DNA alphabet
  * m = 1, w = 1000000, alphabet = DNA
  * m = 2, w = 1000000, alphabet = DNA
  * m = 4, w = 1000000, alphabet = DNA
  * m = 8, w = 1000000, alphabet = DNA
  * m = 16, w = 1000000, alphabet = DNA
==> passed

Test 1c: check correctness of compareTo() with different alphabets
  * m = 2, w = 1000000, alphabet = UNARY
  * m = 2, w = 1000000, alphabet = BINARY
  * m = 2, w = 1000000, alphabet = TERNARY
  * m = 2, w = 1000000, alphabet = UPPERCASE
  * m = 2, w = 1000000, alphabet = BASE64
  * m = 2, w = 1000000, alphabet = ASCII
  * m = 2, w = 1000000, alphabet = EXTENDED_ASCII
  * m = 2, w = 1000000, alphabet = UNICODE
==> passed

Test 1d: check correctness of compareTo() with different languages
  * language = Spanish
  * language = French
  * language = Russian
  * language = Korean
  * language = Vietnamese
==> passed

Test 2a: check that compare() in byReverseWeightOrder() satisfies Comparator contract
  * reflexive:     m = 20, w = 1000000
  * reflexive:     m =  2, w = 10
  * antisymmetric: m = 20, w = 1000000
  * antisymmetric: m =  2, w = 10
  * transitive:    m = 20, w = 1000000
  * transitive:    m =  2, w = 10
  * consistent:    m =  5, w = 100
  * argument is null
==> passed

Test 2b: check correctnes of compare() in byReverseWeightOrder()
  * m = 3, n = 3, w = 10
  * m = 3, n = 3, w = 100
  * m = 3, n = 3, w = 1000
  * m = 6, n = 6, w = 10
  * m = 6, n = 6, w = 100
  * m = 6, n = 6, w = 1000
==> passed

Test 3a: check that compare() in byPrefixOrder(4) satisfies Comparator contract
  * reflexive:     m = 10, w = 1000000
  * reflexive:     m = 10, w = 10
  * antisymmetric: m = 10, w = 1000000
  * antisymmetric: m = 10, w = 10
  * transitive:    m = 10, w = 1000000
  * transitive:    m = 10, w = 10
  * consistent:    m =  6, w = 1000000
  * argument is null
==> passed

Test 3b: check correctness of compare() in byPrefixOrder(r) with different values of r
  * m = 6, n = 6, r = 0, w = 10, alphabet = DNA
  * m = 6, n = 6, r = 1, w = 10, alphabet = DNA
  * m = 6, n = 6, r = 2, w = 10, alphabet = DNA
  * m = 6, n = 6, r = 3, w = 10, alphabet = DNA
  * m = 6, n = 6, r = 4, w = 10, alphabet = DNA
  * m = 6, n = 6, r = 5, w = 10, alphabet = DNA
    - failed on trial 142 of 100000
    - p = new Term("CCTTG", 5)
    - q = new Term("CCTTA", 7)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 1

  * m = 6, n = 6, r = 10, w = 10, alphabet = DNA
    - failed on trial 226 of 100000
    - p = new Term("CTTTAA", 3)
    - q = new Term("CTTTC", 4)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 6, n = 6, r = 100, w = 10, alphabet = DNA
    - failed on trial 227 of 100000
    - p = new Term("CACCACTT", 9)
    - q = new Term("CACCAT", 3)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

==> FAILED

Test 3c: check correctness of compare() in byPrefixOrder(r) with either
         m < r < n or n < r < m
  * m = 4, n = 8, r = 6, w = 10, alphabet = DNA
    - failed on trial 7 of 100000
    - p = new Term("GTGCC", 4)
    - q = new Term("GTGTATTC", 9)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 3, n = 7, r = 5, w = 10, alphabet = DNA
    - failed on trial 6 of 100000
    - p = new Term("ACTG", 5)
    - q = new Term("ACCATACC", 5)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 1

  * m = 2, n = 7, r = 4, w = 10, alphabet = DNA
    - failed on trial 3 of 100000
    - p = new Term("TCT", 2)
    - q = new Term("TCACTGTGT", 9)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 1

  * m = 8, n = 4, r = 6, w = 10, alphabet = DNA
    - failed on trial 91 of 100000
    - p = new Term("CCGCAACCA", 7)
    - q = new Term("CCG", 4)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 6

  * m = 7, n = 3, r = 5, w = 10, alphabet = DNA
    - failed on trial 21 of 100000
    - p = new Term("AAGAGGCC", 5)
    - q = new Term("AATG", 1)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 7, n = 2, r = 4, w = 10, alphabet = DNA
    - failed on trial 2 of 100000
    - p = new Term("AGTTCC", 1)
    - q = new Term("AGT", 8)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 3

==> FAILED

Test 3d: check correctness of compare() in byPrefixOrder(r) with either
         m < n < r or n < m < r
  * m = 2, n = 6, r = 8, w = 10, alphabet = DNA
    - failed on trial 2 of 100000
    - p = new Term("G", 4)
    - q = new Term("GATGG", 3)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -4

  * m = 3, n = 7, r = 10, w = 10, alphabet = DNA
    - failed on trial 2 of 100000
    - p = new Term("ATC", 3)
    - q = new Term("ATGCACAT", 9)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 6, n = 16, r = 22, w = 10, alphabet = DNA
    - failed on trial 8 of 100000
    - p = new Term("AAC", 2)
    - q = new Term("AAGTATAGCGGT", 6)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 6, n = 2, r = 8, w = 10, alphabet = DNA
    - failed on trial 3 of 100000
    - p = new Term("CAGTAC", 1)
    - q = new Term("CAC", 0)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = 1

  * m = 7, n = 3, r = 10, w = 10, alphabet = DNA
    - failed on trial 18 of 100000
    - p = new Term("ACATCTT", 1)
    - q = new Term("ACGC", 1)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

  * m = 16, n = 6, r = 22, w = 10, alphabet = DNA
    - failed on trial 17 of 100000
    - p = new Term("AAAAAATCACAGCTTTT", 4)
    - q = new Term("AAATC", 3)
    - student   compare(p, q)  = 0
    - reference compare(p, q)  = -1

==> FAILED

Test 3e: check correctness of compare() in byPrefixOrder(r) with m = n < r
  * m = 1, n = 1, r = 8, w = 10, alphabet = DNA
  * m = 2, n = 2, r = 3, w = 10, alphabet = DNA
  * m = 3, n = 3, r = 4, w = 10, alphabet = DNA
  * m = 4, n = 4, r = 6, w = 10, alphabet = DNA
  * m = 5, n = 5, r = 7, w = 10, alphabet = DNA
  * m = 9, n = 9, r = 50, w = 10, alphabet = DNA
==> passed

Test 3f: check correctness of compare() in byPrefixOrder(r) with different alphabets
  * m = 8, n = 8, r = 4, w = 10, alphabet = BINARY
  * m = 8, n = 8, r = 4, w = 10, alphabet = UNARY
  * m = 8, n = 8, r = 4, w = 10, alphabet = TERNARY
  * m = 8, n = 8, r = 4, w = 10, alphabet = UPPERCASE
  * m = 8, n = 8, r = 4, w = 10, alphabet = BASE64
==> passed

Test 3g: check correctness of compare() in byPrefixOrder(r) with ASCII
         and Unicode alphabets
  * m = 8, n = 8, r = 1, w = 10, alphabet = ASCII
  * m = 8, n = 8, r = 2, w = 10, alphabet = ASCII
  * m = 8, n = 8, r = 4, w = 10, alphabet = ASCII
  * m = 8, n = 8, r = 1, w = 10, alphabet = EXTENDED_ASCII
  * m = 8, n = 8, r = 2, w = 10, alphabet = EXTENDED_ASCII
  * m = 8, n = 8, r = 4, w = 10, alphabet = EXTENDED_ASCII
  * m = 8, n = 8, r = 1, w = 10, alphabet = UNICODE
  * m = 8, n = 8, r = 2, w = 10, alphabet = UNICODE
  * m = 8, n = 8, r = 4, w = 10, alphabet = UNICODE
==> passed

Test 4: check whether two byPrefixOrder() comparators can be created at the same time
  * m = 8, n = 8, r = 3, w = 10
  * m = 8, n = 8, r = 4, w = 10
  * m = 8, n = 8, r = 3, w = 10
  * m = 8, n = 8, r = 4, w = 10
==> passed

Test 5: check that toString() returns a string in proper format
  * query = ""hello"", weight = 12345678901234
  * query = ""GOODBYE"", weight = 99999999999999
  * query = ""½ λ ☺ ∈ ♬ ❤"", weight = 31415926535898
==> passed

Test 6: call Term constructor with invalid arguments
  * query = "hello", weight = -1
  * query = "hello", weight = -1000
  * query = "hello", weight = -9223372036854775808
  * query = null,    weight = 1
  * query = null,    weight = -1
  * query = null,    weight = 0
==> passed

Test 7: call byPrefixOrder(r) with invalid arguments
  * r = -1
  * r = -2
  * r = -1000
  * r = -2147483648
==> passed


Total: 14/17 tests passed!


================================================================
Testing correctness of BinarySearchDeluxe
*-----------------------------------------------------------
Running 14 total tests.

Tests 1-4 use the following terminology:
  - search hit     = binary search for a query key in the array
  - search miss    = binary search for a query key not in the array
  - false positive = return -1 for a query key in the array
  - false negative = return a non-negative integer for a query key not in array

Test 1a: check firstIndexOf() search hit in random array of between n1 and n2 strings,
         with no duplicate strings
  * n1 = 1, n2 = 4
    - failed on trial 1 of 1000
             0 
      --------
      NJMZUZNL 


      String query = "NJMZUZNL";
      String[] a = { "NJMZUZNL" };

    - n = 1
    - reference firstIndexOf(a, "NJMZUZNL") = 0
    - student   firstIndexOf(a, "NJMZUZNL") = -1
      [ false negative ]

  * n1 = 4, n2 = 8
    - failed on trial 1 of 1000
            0       1       2       3 
      -------------------------------
      DKMRGLF FURJDAM MZDGCOP UJHXIVG 


      String query = "DKMRGLF";
      String[] a = { "DKMRGLF", "FURJDAM", "MZDGCOP", "UJHXIVG" };

    - n = 4
    - reference firstIndexOf(a, "DKMRGLF") = 0
    - student   firstIndexOf(a, "DKMRGLF") = -1
      [ false negative ]

  * n1 = 8, n2 = 12
    - failed on trial 3 of 1000
           0      1      2      3      4      5      6      7      8      9     10     11 
      -----------------------------------------------------------------------------------
      DXYUOV EIDTXK ESMSWJ HRXCZX KXOZTH MSVYLJ RGXFHR TJVNER VNGEME VZUZKJ WRYNBH XQDCTL 


      String query = "KXOZTH";
      String[] a = { "DXYUOV", "EIDTXK", "ESMSWJ", "HRXCZX", "KXOZTH", "MSVYLJ", "RGXFHR", "TJVNER", "VNGEME", "VZUZKJ", "WRYNBH", "XQDCTL" };

    - n = 12
    - reference firstIndexOf(a, "KXOZTH") = 4
    - student   firstIndexOf(a, "KXOZTH") = -1
      [ false negative ]

  * n1 = 12, n2 = 16
    - failed on trial 3 of 1000
          0     1     2     3     4     5     6     7     8     9    10    11    12 
      -----------------------------------------------------------------------------
      AFPQR ALJDB BDMNB CWTZY DRSNG EGFFG FTSYX HDEKD HKDOP ILSPW KSFCY MCRMG ZQQYE 


      String query = "EGFFG";
      String[] a = { "AFPQR", "ALJDB", "BDMNB", "CWTZY", "DRSNG", "EGFFG", "FTSYX", "HDEKD", "HKDOP", "ILSPW", "KSFCY", "MCRMG", "ZQQYE" };

    - n = 13
    - reference firstIndexOf(a, "EGFFG") = 5
    - student   firstIndexOf(a, "EGFFG") = -1
      [ false negative ]

==> FAILED

Test 1b: check firstIndexOf() search hit in random array of between n1 and n2 strings
  * n1 = 30, n2 = 40
    - failed on trial 1 of 1000
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 
      --------------------------------------------------------------------------------------------------------
       A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A 


      String query = "A";
      String[] a = { "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A" };

    - n = 35
    - reference firstIndexOf(a, "A") = 0
    - student   firstIndexOf(a, "A") = 1
      [ 1 is the index of a matching string but not the first such index ]

  * n1 = 20, n2 = 30
    - failed on trial 1 of 1000
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 
      -----------------------------------------------------------------------
      AC AC AC AG AG AG AT CA CA CA CA CT GA GA GA GA GG GG GG GG GT TA TG TG 


      String query = "CA";
      String[] a = { "AC", "AC", "AC", "AG", "AG", "AG", "AT", "CA", "CA", "CA", "CA", "CT", "GA", "GA", "GA", "GA", "GG", "GG", "GG", "GG", "GT", "TA", "TG", "TG" };

    - n = 24
    - reference firstIndexOf(a, "CA") = 7
    - student   firstIndexOf(a, "CA") = 8
      [ 8 is the index of a matching string but not the first such index ]

  * n1 = 15, n2 = 20
    - failed on trial 2 of 1000
        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17 
      -----------------------------------------------------------------------
      AAG AAT ACG AGC AGT CAC CAT CCC CCT CCT CGA CTA GAG GCA GGC GTT TAG TTG 


      String query = "CCC";
      String[] a = { "AAG", "AAT", "ACG", "AGC", "AGT", "CAC", "CAT", "CCC", "CCT", "CCT", "CGA", "CTA", "GAG", "GCA", "GGC", "GTT", "TAG", "TTG" };

    - n = 18
    - reference firstIndexOf(a, "CCC") = 7
    - student   firstIndexOf(a, "CCC") = -1
      [ false negative ]

  * n1 = 10, n2 = 15
    - failed on trial 1 of 1000
         0    1    2    3    4    5    6    7    8    9 
      -------------------------------------------------
      AABA AABB ABBA ABBA ABBB BAAA BAAB BABB BBAA BBBB 


      String query = "AABA";
      String[] a = { "AABA", "AABB", "ABBA", "ABBA", "ABBB", "BAAA", "BAAB", "BABB", "BBAA", "BBBB" };

    - n = 10
    - reference firstIndexOf(a, "AABA") = 0
    - student   firstIndexOf(a, "AABA") = -1
      [ false negative ]

==> FAILED

Test 2a: check lastIndexOf() search hit in random array of between n1 and n2 strings,
         with no duplicate strings
  * n1 = 1, n2 = 4
   - failed on trial 1 of 1000
             0        1        2 
      --------------------------
      DYGGPILZ HCVZDVQB VZMLEDBU 


      String query = "VZMLEDBU";
      String[] a = { "DYGGPILZ", "HCVZDVQB", "VZMLEDBU" };

    - n = 3
    - reference lastIndexOf(a, "VZMLEDBU") = 2
    - student   lastIndexOf(a, "VZMLEDBU") = -1
      [ false negative ]

  * n1 = 4, n2 = 8
   - failed on trial 1 of 1000
            0       1       2       3       4       5       6       7 
      ---------------------------------------------------------------
      CEKXAPA CKOROMZ FLUCGZI ICQDNMI IDPROVN LMEUVEA TXDLPTE YAIRWSO 


      String query = "YAIRWSO";
      String[] a = { "CEKXAPA", "CKOROMZ", "FLUCGZI", "ICQDNMI", "IDPROVN", "LMEUVEA", "TXDLPTE", "YAIRWSO" };

    - n = 8
    - reference lastIndexOf(a, "YAIRWSO") = 7
    - student   lastIndexOf(a, "YAIRWSO") = -1
      [ false negative ]

  * n1 = 8, n2 = 12
   - failed on trial 2 of 1000
           0      1      2      3      4      5      6      7      8      9     10 
      ----------------------------------------------------------------------------
      BJJWQC CGGCXM CXKVBH DQQFMC HVDWIB IMETAT LHUZHJ OZPFTD QFCJOC SJXVCP XXRMHV 


      String query = "OZPFTD";
      String[] a = { "BJJWQC", "CGGCXM", "CXKVBH", "DQQFMC", "HVDWIB", "IMETAT", "LHUZHJ", "OZPFTD", "QFCJOC", "SJXVCP", "XXRMHV" };

    - n = 11
    - reference lastIndexOf(a, "OZPFTD") = 7
    - student   lastIndexOf(a, "OZPFTD") = -1
      [ false negative ]

  * n1 = 12, n2 = 16
   - failed on trial 2 of 1000
          0     1     2     3     4     5     6     7     8     9    10    11    12    13    14 
      -----------------------------------------------------------------------------------------
      CUQBE DCRKX GOLUP JPAWA LAKJZ PZNGG QYXGL RNAHS SPJAR TEHXW UCZXA WKNSE XGRVA YLABT ZKGXV 


      String query = "SPJAR";
      String[] a = { "CUQBE", "DCRKX", "GOLUP", "JPAWA", "LAKJZ", "PZNGG", "QYXGL", "RNAHS", "SPJAR", "TEHXW", "UCZXA", "WKNSE", "XGRVA", "YLABT", "ZKGXV" };

    - n = 15
    - reference lastIndexOf(a, "SPJAR") = 8
    - student   lastIndexOf(a, "SPJAR") = -1
      [ false negative ]

==> FAILED

Test 2b: check lastIndexOf() search hit in random array of between n1 and n2 strings
  * n1 = 30, n2 = 40
   - failed on trial 1 of 1000
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 
      -----------------------------------------------------------------------------------------
       A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A  A 


      String query = "A";
      String[] a = { "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A", "A" };

    - n = 30
    - reference lastIndexOf(a, "A") = 29
    - student   lastIndexOf(a, "A") = 28
      [ 28 is the index of a matching string but not the last such index ]

  * n1 = 20, n2 = 30
   - failed on trial 1 of 1000
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 
      -----------------------------------------------------------------------------------
      AA AA AA AC AC AC AG AT AT CA CA CA CA CC CG CG CG CG GG GT GT GT TA TA TC TG TT TT 


      String query = "AC";
      String[] a = { "AA", "AA", "AA", "AC", "AC", "AC", "AG", "AT", "AT", "CA", "CA", "CA", "CA", "CC", "CG", "CG", "CG", "CG", "GG", "GT", "GT", "GT", "TA", "TA", "TC", "TG", "TT", "TT" };

    - n = 28
    - reference lastIndexOf(a, "AC") = 5
    - student   lastIndexOf(a, "AC") = 4
      [ 4 is the index of a matching string but not the last such index ]

  * n1 = 15, n2 = 20
   - failed on trial 4 of 1000
        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
      ---------------------------------------------------------------
      AAC ACA AGT CAC CCT CGT CTA CTC GAT GTA GTG GTT TGG TTA TTT TTT 


      String query = "CTA";
      String[] a = { "AAC", "ACA", "AGT", "CAC", "CCT", "CGT", "CTA", "CTC", "GAT", "GTA", "GTG", "GTT", "TGG", "TTA", "TTT", "TTT" };

    - n = 16
    - reference lastIndexOf(a, "CTA") = 6
    - student   lastIndexOf(a, "CTA") = -1
      [ false negative ]

  * n1 = 10, n2 = 15
   - failed on trial 2 of 1000
         0    1    2    3    4    5    6    7    8    9   10   11 
      -----------------------------------------------------------
      AAAA ABAB ABBA BAAA BAAA BAAA BAAB BBAB BBAB BBAB BBBA BBBB 


      String query = "BBAB";
      String[] a = { "AAAA", "ABAB", "ABBA", "BAAA", "BAAA", "BAAA", "BAAB", "BBAB", "BBAB", "BBAB", "BBBA", "BBBB" };

    - n = 12
    - reference lastIndexOf(a, "BBAB") = 9
    - student   lastIndexOf(a, "BBAB") = 8
      [ 8 is the index of a matching string but not the last such index ]

==> FAILED

Test 3a: check firstIndexOf() search miss in random array of between
         n1 and n2 strings, with no duplicates
  * n1 = 1, n2 = 4
  * n1 = 4, n2 = 8
  * n1 = 8, n2 = 12
  * n1 = 12, n2 = 16
==> passed

Test 3b: check firstIndexOf() search miss in random array of between n1 and n2 strings
  * n1 = 16, n2 = 31
  * n1 = 8, n2 = 15
  * n1 = 4, n2 = 7
==> passed

Test 4a: check lastIndexOf() search miss in random array of between n1 and n2 strings,
         with no duplicate strings
  * n1 = 1, n2 = 4
  * n1 = 4, n2 = 8
  * n1 = 8, n2 = 12
  * n1 = 12, n2 = 16
==> passed

Test 4b: check lastIndexOf() search miss in random array of between n1 and n2 strings
  * n1 = 16, n2 = 31
  * n1 = 8, n2 = 15
  * n1 = 4, n2 = 7
==> passed

Test 5: check lastIndexOf() and firstIndexOf() in array of length 0
  * n = 0
  * n = 0
==> passed

Test 6: check lastIndexOf() and firstIndexOf() with null arguments
  * a = not null, key = not null, comparator =     null
  * a = not null, key =     null, comparator = not null
  * a = not null, key =     null, comparator =     null
  * a =     null, key = not null, comparator = not null
  * a =     null, key = not null, comparator =     null
  * a =     null, key =     null, comparator = not null
  * a =     null, key =     null, comparator =     null
==> passed

Test 7: check lastIndexOf() and firstIndexOf() on a data type for which
        equal keys are not necessarily reference equal
  * n = 5 random strings
    - failed on trial 11 of 1000
       0  1  2  3  4 
      --------------
       H  N  O  W  Z 


      String query = "N";
      String[] a = { "H", "N", "O", "W", "Z" };

      for (int i = 0; i < a.length; i++)
          a[i] = new String(a[i]);

    - n = 5
    - reference firstIndexOf(a, "N") = 1
    - student   firstIndexOf(a, "N") = -1
    - reference  lastIndexOf(a, "N") = 1
    - student    lastIndexOf(a, "N") = -1
      [ false negative for firstIndexOf() ]
      [ false negative for lastIndexOf() ]

  * n = 10 random strings
    - failed on trial 8 of 1000
       0  1  2  3  4  5  6  7  8  9 
      -----------------------------
       A  B  B  F  I  J  O  R  X  Z 


      String query = "Z";
      String[] a = { "A", "B", "B", "F", "I", "J", "O", "R", "X", "Z" };

      for (int i = 0; i < a.length; i++)
          a[i] = new String(a[i]);

    - n = 10
    - reference firstIndexOf(a, "Z") = 9
    - student   firstIndexOf(a, "Z") = -1
    - reference  lastIndexOf(a, "Z") = 9
    - student    lastIndexOf(a, "Z") = -1
      [ false negative for firstIndexOf() ]
      [ false negative for lastIndexOf() ]

  * n = 15 random strings
    - failed on trial 9 of 1000
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 
      --------------------------------------------
       A  E  I  I  J  J  K  L  M  P  Q  U  W  W  Y 


      String query = "K";
      String[] a = { "A", "E", "I", "I", "J", "J", "K", "L", "M", "P", "Q", "U", "W", "W", "Y" };

      for (int i = 0; i < a.length; i++)
          a[i] = new String(a[i]);

    - n = 15
    - reference firstIndexOf(a, "K") = 6
    - student   firstIndexOf(a, "K") = -1
    - reference  lastIndexOf(a, "K") = 6
    - student    lastIndexOf(a, "K") = -1
      [ false negative for firstIndexOf() ]
      [ false negative for lastIndexOf() ]

==> FAILED

Test 8: check lastIndexOf() and firstIndexOf() on a data type for which
        compare() is inconsistent with equals()
  * n = 5 random integers between 0 and 99
    - failed on trial 571 of 1000
    - a[] = { 0 4 25 78 84 }
    - reference firstIndexOf(a, "4") = 1
    - student   firstIndexOf(a, "4") = -1
    - reference  lastIndexOf(a, "4") = 1
    - student    lastIndexOf(a, "4") = -1

  * n = 10 random integers between 0 and 99
    - failed on trial 49 of 1000
    - a[] = { 9 36 37 63 75 88 91 92 93 97 }
    - reference firstIndexOf(a, "9") = 0
    - student   firstIndexOf(a, "9") = -1
    - reference  lastIndexOf(a, "9") = 0
    - student    lastIndexOf(a, "9") = -1

  * n = 20 random integers between 0 and 99
    - failed on trial 7 of 1000
    - a[] = { 13 20 21 28 28 28 36 37 45 52 64 65 78 79 81 82 83 94 94 95 }
    - reference firstIndexOf(a, "13") = 0
    - student   firstIndexOf(a, "13") = -1
    - reference  lastIndexOf(a, "13") = 0
    - student    lastIndexOf(a, "13") = -1

==> FAILED

Test 9: check that lastIndexOf() and firstIndexOf() don't assume
        compare() can return only -1, 0, or +1
  * n = 5 random integers between 0 and 99
    - failed on trial 60 of 1000
    - a[] = { 3 3 51 54 79 }
    - reference firstIndexOf(a, "3") = 0
    - student   firstIndexOf(a, "3") = 0
    - reference  lastIndexOf(a, "3") = 1
    - student    lastIndexOf(a, "3") = 0

  * n = 10 random integers between 0 and 99
    - failed on trial 8 of 1000
    - a[] = { 3 6 16 22 42 49 51 51 67 72 }
    - reference firstIndexOf(a, "3") = 0
    - student   firstIndexOf(a, "3") = -1
    - reference  lastIndexOf(a, "3") = 0
    - student    lastIndexOf(a, "3") = -1

  * n = 20 random integers between 0 and 99
    - failed on trial 13 of 1000
    - a[] = { 15 19 21 23 29 32 34 35 35 49 50 57 61 69 70 78 82 83 91 99 }
    - reference firstIndexOf(a, "15") = 0
    - student   firstIndexOf(a, "15") = -1
    - reference  lastIndexOf(a, "15") = 0
    - student    lastIndexOf(a, "15") = -1

==> FAILED

Test 10: check that lastIndexOf() and firstIndexOf() don't mutate the argument array
==> passed


Total: 7/14 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Term and BinarySearchDeluxe)
********************************************************************************

Testing correctness of Autocomplete
*-----------------------------------------------------------
Running 12 total tests.

Test 1: check allMatches() on search hits
  * file = fortune1000-randomly-ordered.txt
  * file = wiktionary.txt
  * file = baby-names.txt
  * file = cities.txt
  * file = words-100000.txt
==> passed

Test 2: check allMatches() with empty prefix
  * file = fortune1000-randomly-ordered.txt
  * file = wiktionary.txt
  * file = baby-names.txt
  * file = cities.txt
==> passed

Test 3: check allMatches() on an input that contains unusual query strings
  * file = empty-string.txt
  * file = empty-string.txt
==> passed

Test 4: check allMatches() on search misses
  * file = fortune1000-randomly-ordered.txt
  * file = wiktionary.txt
  * file = baby-names.txt
  * file = cities.txt
==> passed

Test 5: check numberOfMatches() on search hits
  * file = fortune1000-randomly-ordered.txt
  * file = wiktionary.txt
  * file = cities.txt
==> passed

Test 6: check numberOfMatches() on search misses
  * file = fortune1000-randomly-ordered.txt
    - failed on trial 1 of 100
    - student      numberOfMatches("PG&E &") = 1
    - reference    numberOfMatches("PG&E &") = 0

  * file = wiktionary.txt
    - failed on trial 1 of 500
    - student      numberOfMatches("instri") = 1
    - reference    numberOfMatches("instri") = 0

  * file = cities.txt
    - failed on trial 1 of 2500
    - student      numberOfMatches("Ag-amba") = 1
    - reference    numberOfMatches("Ag-amba") = 0

==> FAILED

Test 7: check that Autocomplete doesn't mutate Term[]
  * file = cities.txt
    - the terms[] argument to Autcomplete() was modified
    - do not modify the terms[] array
    - instead, create a defensive copy, and modify that array

==> FAILED

Test 8: check what happens when client mutates Term[] after construction
  * file = cities.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 6
    - 6 missing entries in student solution, including:
      '741	Bettenfeld, Germany'


    - failed on trial 1 of 100
    - prefix = "Bette"

==> FAILED

Test 9: check what happens when client mutates return value of allMatches()
  * file = cities.txt
==> passed

Test 10: check that two Autocomplete objects can be created at the same time
  * file1 = wiktionary.txt, file2 = wiktionary.txt
  * file1 = wiktionary.txt, file2 = baby-names.txt
  * file1 = baby-names.txt, file2 = wiktionary.txt
==> passed

Test 11: check that allMatches() returns array of length zero for search miss
  * file = wiktionary.txt
  * file = baby-names.txt
==> passed

Test 12: call constructor and methods with invalid arguments
  * call constructor with null argument
  * call constructor with null entry in argument array
  * call allMatches() with null argument
  * call numberOfMatches() with null argument
==> passed


Total: 9/12 tests passed!


================================================================
********************************************************************************
*  TIMING (substituting reference Term and BinarySearchDeluxe)
********************************************************************************

Timing Autocomplete
*-----------------------------------------------------------
Running 5 total tests.

Test 1: call allMatches() and count calls to methods in BinarySearchDeluxe
  * filename = cities.txt, r = 5
  * filename = cities.txt, r = 2
  * filename = cities.txt, r = 1
==> passed

Test 2: call numberOfMatches() and count calls to methods in BinarySearchDeluxe
  * filename = cities.txt, r = 5
  * filename = cities.txt, r = 2
  * filename = cities.txt, r = 1
==> passed

Test 3: call constructor and count calls to methods in Term
  * filename = wiktionary.txt
    - calls to compareTo()         =  120309  
    - calls to toString()          =       0  
    - calls to compare() by weight =       0  
    - calls to compare() by prefix =       0  

  * filename = cities.txt
    - calls to compareTo()         = 1430110  
    - calls to toString()          =       0  
    - calls to compare() by weight =       0  
    - calls to compare() by prefix =       0  

==> passed

Test 4: call allMatches() k times with random r-character prefixes
        and count calls to methods in Term
  * filename = cities.txt, k = 1000, r = 2
    - calls to compareTo()         =       0  
    - calls to toString()          =       0  
    - calls to compare() by weight = 9463782  
    - calls to compare() by prefix =   35283  

==> passed

Test 5: call numberOfMatches() k times with random r-character prefixes
        and count calls to methods in Term
  * filename = cities.txt, k = 1000, r = 2
    - calls to compareTo()         =       0  
    - calls to toString()          =       0  
    - calls to compare() by weight =       0  
    - calls to compare() by prefix =   35275  

==> passed


Total: 5/5 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing BinarySearchDeluxe
*-----------------------------------------------------------
Running 4 total tests.

Test 1: Count calls to compare() on arrays of random integers between 0 and 100.
        Table shows maximum number of calls to compare() calls during 1000 trials.
        [  max allowed is 2 + ceil(log_2(n)) ]

                firstIndexOf()        lastIndexOf()
        n        miss         hit        miss         hit     allowed
_____________________________________________________________________
        1          0           0           0           0           2
        2          2           2           2           2           3
        3          2           2           2           2           4
        4          4           4           4           4           4
        5          4           4           4           4           5
        6          4           4           4           4           5
        7          4           4           4           4           5
        8          6*          6*          6*          6*          5
        9          6           6           6           6           6
       10          6           6           6           6           6
       11          6           6           6           6           6
       12          6           6           6           6           6
       13          6           6           6           6           6
       14          6           6           6           6           6
       15          6           6           6           6           6
       16          8*          8*          8*          8*          6
      100         10*         11*         11*         11*          9
     1000         18*         18*         18*         18*         12
    10000         26*         26*         26*         26*         16
   100000         32*         32*         32*         32*         19
  1000000         38*         38*         38*         38*         22
==> FAILED

Test 2: Count calls to compare() on arrays containing integer keys all equal to 0.
        Table shows maximum number of calls to compare() calls during 1000 trials.
        [  max allowed is 2 + ceil(log_2(n)) ]

                firstIndexOf()        lastIndexOf()
        n        miss         hit        miss         hit     allowed
_____________________________________________________________________
       10          6           6           6           6           6
      100         12*         12*         12*         12*          9
     1000         18*         18*         18*         18*         12
    10000         26*         26*         26*         26*         16
   100000         32*         32*         32*         32*         19
  1000000         38*         38*         38*         38*         22
==> FAILED

Test 3: Count calls to compare() on sorted arrays of 0s and 1s.
        Table shows maximum number of calls to compare() calls during 1000 trials.
        [  max allowed is 2 + ceil(log_2(n)) ]

                firstIndexOf()        lastIndexOf()
        n        miss         hit        miss         hit     allowed
_____________________________________________________________________
       10          6           6           6           6           6
      100         12*         12*         12*         12*          9
     1000         18*         18*         18*         18*         12
    10000         26*         26*         26*         26*         16
   100000         32*         32*         32*         32*         19
  1000000         38*         38*         38*         38*         22
==> FAILED

Test 4: Count calls to compare() on sorted arrays of random integers between 0 and 1000000.
        Table shows maximum number of calls to compare() calls during 1000 trials.
        [  max allowed is 2 + ceil(log_2(n)) ]

                firstIndexOf()        lastIndexOf()
        n        miss         hit        miss         hit     allowed
_____________________________________________________________________
       10          6           6           6           6           6
      100         10*         10*         10*         10*          9
     1000         14*         17*         17*         17*         12
    10000         17*         21*         21*         21*         16
   100000         25*         27*         27*         27*         19
  1000000         32*         32*         32*         32*         22
==> FAILED


Total: 0/4 tests passed!


================================================================



********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of Term
*-----------------------------------------------------------
Running 3 total tests.

Test 1: memory of new Term("autocomplete", 10)
        [ must be <= 1.1x reference solution ]
  - memory of student   Term = 104 bytes
  - memory of reference Term = 104 bytes
  - student / reference      = 1.00
==> passed

Test 2: memory of new Term("binary search", 20)
        [ must be <= 1.1x reference solution ]
  - memory of student   Term = 104 bytes
  - memory of reference Term = 104 bytes
  - student / reference      = 1.00
==> passed

Test 3: memory of new Term("sort", 139)
        [ must be <= 1.1x reference solution ]
  - memory of student   Term = 96 bytes
  - memory of reference Term = 96 bytes
  - student / reference      = 1.00
==> passed


Total: 3/3 tests passed!


================================================================



Analyzing memory of Autocomplete
*-----------------------------------------------------------
Running 3 total tests.

Test 1: memory with wiktionary.txt (must be <= 1.1x reference solution).
  - memory of Terms[]                = 1058712 bytes
  - memory of student   Autocomplete = 1058736 bytes
  - memory of reference Autocomplete = 1058736 bytes
  - student / reference              = 1.00
==> passed

Test 2: memory with cities.txt (must be <= 1.1x reference solution).
  - memory of Terms[]                = 11525896 bytes
  - memory of student   Autocomplete = 11525920 bytes
  - memory of reference Autocomplete = 11525920 bytes
  - student / reference              = 1.00
==> passed

Test 3: memory with words-333333.txt (must be <= 1.1x reference solution).
  - memory of Terms[]                = 35508192 bytes
  - memory of student   Autocomplete = 35508216 bytes
  - memory of reference Autocomplete = 35508216 bytes
  - student / reference              = 1.00
==> passed


Total: 3/3 tests passed!


================================================================




